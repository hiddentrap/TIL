# RDBMS 모델링

## 관계형 데이터베이스

### 관계(R)정의

- 1:M 부자지간
- M:N 비니스
- 1:1 부부간

### 고유 식별자

- NOT NULL, UNIQUE

### 참조 무결성

- **참조하는 컬럼의 값은 참조되는 컬럼값의 집합(도메인)중의 값이어야 한다.**
- 1:M에서 절대적으로 중요함
- 외래키

### 테이블 속성

- 테이블: 엔티티
- 세로줄: 열, 컬럼, 필드, 속성
- 가로줄: 행, 로우, 튜플, 레코드

### 주식별자 (Primary Key)

- 주식별자가 없을경우 Duplication이 허용되므로 문제가됨
- 식별자 = Unique
- 주식별자 = Not Null and Unique 

## KEY

### 키의 정의

- ex: 주민번호, 고객명, 폰번호, 이메일, 집주소, 고객번호

- 주 식별자: not null only one in 후보 식별자로 **최소한의 속성 조합으로 한다.**
- 후보 식별자: Unique한 key중 주식별자 이외의 키
- **고객들이 제공한 데이터는 주식별자로 피하는게 좋음 (ex, 주민번호), 회사(우리)가 부여한 데이터를 권장 (ex, 고객번호)**
- 나머지 키는 인덱스를 만드는데 활용한다.

### DATA TYPE

- 화폐단위는 decimal, numeric 사용
- 사이즈가 큰 varchar나 text등은 sort나 key로 사용하면 안됨
- Nchar, nvarchar, Ntext: 유니코드 데이터형

## Primary Key 설계

- Unique and Not Null 일 수 있는 컬럼을 찾는다.
- 후보 식별자가 없는 경우 임의의 인조 식별자를 만들어 부여한다.
  - PK의 데이터 타입 결정
    - 레코드의 발생 가능한 최대 수를 예측한다.
      - 1년에 몇 개 정도 발생하는가? 한 달에 몇개정도 발생하는가?
      - 처리해야 하는 대상이 대략 몇 개정도 되는가?
      - 갯수가 결정되는 테이블
        - 대상 레코드가 수십 만개 정도라면 999,999로 커버
          - 32bit int or varchar(6)으로 가능
      - **시간을 축으로 데이터가 쌓여가는 테이블**
        - **(연도)+(월)+(일)+시퀀스번호**
    - int 등 숫자를 PK로 사용할 경우 자동 증분으로 편리함
    - String을 사용하면 문자를 섞어서 PK값에 의미 부여 가능: 채번시스템이 필요
    - 특별한 의미 부여가 필요 없는 경우 정수형이 바람직

## 1:M 부자간의 관계 (포함 관계)

- **관계는 2개 테이블 사이에만 존재**
- 부모와 자식 관계 또는 컴퓨터 디렉토리 구조, 트리 구조, 버스와 버스안의 좌석사 사이의 관계, 반과 학생, 
- 자식은 부모에 종속된다. 부모의 PK는 자식의 FK(외래키, 중복가능)
- 자식은 없을 수 있지만, 부모는 없을 수 없다. FK = Not Null and 참조무결성 체크
- 부모의 PK와 자식의 FK이름을 동일하게 써야 헷갈리지 않는다.
- 학년과 반
  - 부모 : 학년 (PK = 학년번호)
  - 자식 : 반 (PK = 학년번호, 반번호 / FK = 학년번호)
- 회사 모델링 (Key 및 관계부터 설계 그뒤 필요 정보(컬럼) 추가하는 식으로 모델링)
  - 회사 모델링
    - CompanyId (int, PK, 자동증분)
    - CompanyName (varchar(50), NotNull)
  - 부서 모델링
    - DeptId (smallint, PK)
    - DeptName (varchar(50), NotNull)
    - CompanyId (int, PK, FK from 회사)
  - 관계 설정
    - 부서의 PK를 DeptId + ComapnyId 로 하거나
    - ComapnyId를 NotNull 설정
- 부모 데이터부터 추가되어야 자식 데이터 추가 가능
- 부모와 연결된 자식이 있을경우 부모 데이터 삭제 불가

## 1:M 재귀적관계

- (부서) 상위부서 : 하위부서 : 하위부서 : ...
- (분류) 대분류 : 중분류 : 소분류 : ...
- (디렉토리) 상위디렉토리 : 서브 디렉토리 : 서브 디렉토리 : ...
- 부서: 모델링
  - DeptId (samllint, PK)
  - DeptName (varchar(50), Not Null)
  - 상위부서ID (int, Not Null, FK from 부서 자기자신, 최상위 부서의 상위부서는 없을 수 있으므로 null가능)
  - 하위부서 ID 모델링은 불가, 하위부서가 M개가 올수 있으므로 한 컬럼안에 불가로 모델링 불가
  - CompanyId (int, FK from 회사) * option
- select * from 부서 a join 부서 b on a.부서Id = b.상위부서Id
- select * from 부서 a join 부서 b on a.부서Id = b.상위부서Id wehre a.부서Id = 2 : 특정 부서 정보
- select * from 부서 a left outer join 부서 b on a.부서Id = b.상위부서Id

## M:N 관계 (양방향 1:M) 비지니스(수요와 공급의 행위) 관계

- 학생 : 과목
  - A학생은 국, 영, 수 수강
  - 국어는 A, B, C 학생이 수강
- M:N 관계를 해결하기 위해서 또 하나의 테이블이 필요 (관계 테이블)
  - 주어(누가) 목적어(무엇을) 동사(~하다)
  - 학생이 과목을 수강한다. -> 학생, 과목, 수강
  - 명사 (학생, 과목) 테이블은 레코드 총량이 유지되는 특성이 있다.
  - 동사 (수강) 테이블은 시간을 축으로 데이터가 쌓여가는 특성이 있다. 그래서 시간 속성을 가져가는 경향
  - 학생 (주어, 실체) : 수강(동사, 계약 관계) :과목(목적어, 실체)
    - 학생
      - ID (PK)
      - 성명
    - 수강 (관계테이블에 독립형 PK를 사용하는 모델: 중복행위 가능)
      - Seq (PK)
      - 학생ID (FK)
      - 과목ID (FK)
    - 수강 (관계 테이블에 상속형 PK를 사용하는 모델 : 중복행위 불가)
      - 학생ID (PK, FK)
      - 과목ID( PK, FK)
    - 수강 (관계 테이블에 PK와 대체키(보조키, Alternate Key)를 사용하는 모델 : 중복행위 불가)
    - **보조키의 목적: 복합 PK를 편하게 사용하기 위험**
      - Seq (AK, Not null)
      - 학생ID (PK, FK)
      - 과목ID (PK, FK)
    - 과목
      - ID (PK)
      - 과목명 (FK)
  - 관계테이블 (동사)의 관련 실체 (명사)는 꼭 2개일 필요는 없다
    - 관계테이블에 보조키(Not Null 필수)가 겁나 필요한 상황: 중족행위 불가한 관계테이블에 관련 실체가 N개 이상이 되면서 관계테이블의 복합 PK를 구성하는 FK컬럼이 N개로 증가하여 사용이 불편하게 되는 상황

## 1:1 관계 (부부관계)

-  두개의 테이블이 하나로 합쳐질 수 있긴 함

- 서로 참조

  - ```
    select * from 신랑 a full outer join 신부 b on a.신랑Id = b.신랑Id
    ```

- 신랑 : 신부

  - 초기
    - 신랑
      - 신랑Id (PK)
      - 신랑이름 (Not Null)
      - 신부Id (FK from 신부)
    - 신부
      - 신부Id (PK)
      - 신부이름 (Not Null)
      - 신랑Id (FK from 신랑)
  - 하나의 테이블로 구현 (비합리적)
    - 부부
      - 신랑신부Id (PK)
      - 신랑이름
      - 신부이름
  - 권장되는 테이블 형태
    - 신랑
      - 신랑Id (PK, FK from 신부)
      - 신랑이름 (Not Null)
    - 신부
      - 신부Id (PK, FK from 신랑)
      - 신부이름 (Not Null)

- 파일철 : 문서 : 문서 종류별 Meta

  - 파일철 : 문서  =  1:M
  - 문서 : 문서 종류별 Meta = 1:1
  - 파일철: 문서 공통 컬럼 (제목, 생산기관, 보존연한) : 문서 종류별 Detail (출입국대장 or 회계전표 or ...)
  - 수 많은 문서종류 테이블 중 어떤 테이블과 문서 공통 테이블을 join 할 수 있을까?
    - 문서 공통 테이블에 해당하는 문서 종류 테이블명을 기술하는 컬럼을 추가한다.

## 모델링 연습

### 도서관의 도서 대출 관리

- 도서관의 도서 대출 관리 UseCase

  - 도서관에는 각 서고/서가에 많은 책들이 있다
  - 고객들은 인터넷을 통해서 로그인한 후 도서 목록을 조회할 수 있다.
  - 고객들은 원하는 책을 대출 받을 수 있다.
  - 고객은 책이 있을 경우 대출 예약을 할 수 있으며 대출을 위해서는 직접 방문해서 책을 찾아서 대출을 해야 한다.

- 정리, 명사와 동사만 남긴다.

  - 도서관,  서고, 서가, 책
  - 고객, 로그인, 도서목록, 조회, 대출(고객이 방문 대출), 대출예약

- 마스터테이블 후호 색출

  - 서고, 서가, 책
  - 고객, 도서목록

- 관계테이블 후보 색출

  - 로그인, 조회, 대출(고객이 방문 대출), 대출예약

- 논리적 설계 (물리적 설계전으로 PK, FK, 주요 컬럼만)

  - 마스터테이블 모델링 1단계
    - 서고 > 서가 > 책 (1:M)
    - 서고
      - 서고Id (PK)
    - 서가
      - 서가Id (PK)
    - 책
      - 책Id (PK)
    - 고객
      - 고객Id (PK)
      - 고객명 (Not Null)
    - 도서목록
      - 도서목록Id (PK)
  - 마스터테이블 모델링 2단계
    - 서고 > 서가 > 책 (1:M)
    - 서고
      - 서고Id (PK)
      - 서고명 (Not Null)
    - 서가
      - 상속형 PK (1-1, 1-2, 2-1, 2-2 서고-서가 make sense, 부모선등록이 필수, 엄격)
        - 서가 Id (PK)
        - 서고 Id (PK, FK from 서고, Not Null)
        - 서가명 (Not Null)
      - 독립형PK (1-1, 1-2, 2-3, 2-4 서고-서가 어색함, 부모없이 등록가능, 융통성)
        - 서가Id (PK)
        - 서고Id (FK from 서고)
        - 서가명 (Not Null)
    - 층
      - 서고Id (PK, FK from 서가)
      - 서가Id (PK, FK From 서가)
      - 층Id (PK)
      - 층명 (Not Null)
    - 층열
      - 열번호 (PK)
      - 층Id (PK, FK from 층)
      - 서가Id (PK, FK from 층)
      - 서고Id (PK, FK from 층)
    - 책 (**상속형은 Depth가 늘어날때마다 PK가 늘어나는 단점이 있음**, 따라서 보조키(대체키) 생성 사용)
      - **책Seq (AK, Not Null)**
      - 책Id (PK, FK from 도서목록 (도서목록Id))
      - 열번호 (FK From 층열)
      - 층Id (FK From 층열)
      - 서가Id (FK From 층열)
      - 서고Id (FK from 층열)
    - 도서목록: 기본
      - 목록Id (PK, FK from 책 (책Id), FK from 일반책자정보, FK from 잡지정보, FK from 논문정보)
      - 테이블명
      - 책제목
      - 저자
      - 출판사
      - 구분Id (FK from 책구분)
    - 일반책자정보
      - 세부정보Id (PK, FK from 도서목록:기본)
      - ISBN번호
    - 잡지정보
      - 세부정보Id (PK, FK from 도서목록:기본)
    - 논문정보
      - 세부정보Id (PK, FK from 도서목록:기본)
    - 책구분 (기준테이블)
      - 구분Id (PK)
      - 구분명
    - 고객
      - 고객Id (PK)
      - 고객명 (Not Null)
      - 성별코드 (bit, FK from 성별)
    - 성별
      - 성별코드 (PK, bit)
      - 성별 (varchar(50))
  - 관계테이블 모델링
    - 대출
      - 일련번호(PK, Autoincremental)
      - 책seq (FK from 책)
      - 고객Id ( FK from 고객)
      - 대출일
      - 반납예정일
      - 반납일

  

### 중학교 학생 성적관리 프로젝트

- UseCase

  - 중학교 학생 성적관리 프로젝트 
    - 과목은 학년별로 담당 선생님이 따로 있다.
    - 시험은 중간고사, 기말고사 두 가지가 있다.
    - 학생들은 학년, 반에 배정되며 반별로 학생들에게 고유 번호를 부여하고 있다.
    - 각 반에는 담임 선생님이 배정되어 있다. 선생님 중에는 담임을 맡지 않는 선생님도 있다.
    - 한 반의 학생은 대략 40명 정도이고 남녀 공학이다.
    - 석차는 남녀 공통 1등부터 순서대로 정한다.

- 정리: 명사와 동사만 남긴다.

  - 중학교 학생 성적관리 프로젝트 
    - 과목, 담당선생님
    - 시험, 중간고사, 기말고사
    - 학생, 학년, 반, 배정, 고유번호(반별)
    - 담임, 선생님
    - --한 반의 학생은 대략 40명 정도
    - 석차(남녀 공통 1등부터 순서대로)

- 테이블 후보 추출

  - 중학교(남녀공학) 학생 성적관리 프로젝트
  - 마스터 테이블
    - 학생(40명정도/반, 반별 고유번호 존재), 학년, 반
    - 과목(학년별 담당선생님 별도 존재), 선생님(담임/비담임)
    - 성적 (반/학년 석차)
    - 시험(중간고사, 기말고사)
  - 관계 테이블
    - 시험(보다), 배정(하다), 개강(하다)
  - 비지니스
    - 학생은 과목을 시험본다

- 관계 추출

  - 1: M
    - 학년 : 반
    - 반 : 학생

- 논리 모델링 -> 물리 모델링(PreFix: TB_Table, VW_View, SP_StoredProcedure)

  - 학년 (기준테이블 : 절대 Parent테이블, 어떤 테이블의 자식 테이블이 되지 않는 테이블, Select 프로시져만 생성해야함. 초기 세팅때 이외에는 CUD가 필요 없는 테이블, 도메인을 결정하는 역할) -> TB_SchoolGrade

    - 학년Id (PK) -> SchoolGradeId (tinyint)
    - 학년명 (Not Null) -> SchoolGradeName (varchar(50))

  - 반 -> TB_SchoolClass

    - 학년Id (PK, FK from 학년) -> SchoolGradeId (tinyint)
    - 반Id (PK) -> SchoolClassId (tinyint)
    - 반이름 (Not Null) -> SchoolCalssName (varchar(50))
    - 사용유무 (Not Null) -> useFlag (bit) : 부모없는 자식을 만들지 않기위함
    - 선생님Id (FK from 선생님, Not Null) -> TeacherId (tinyint)
    - 배정일 (Not Null) -> AssignedDate (date)

  - 학생 -> TB_Student

    - 학생Id (PK) -> StudentId (bigint)
    - 학년Id (FK from 반, Not null) -> SchoolGrade (tinyint)
    - 반Id ( FK from 반) -> SchoolClassId (tinyint) : 신입생은 반배정전에 반이 없음

    - 학생Seq (desc: 반별 학생고유번호) : 신입생은 반배정전에 반별 학생고유번호 없음
    - 학생성명 (Not Null) -> StudentName (varchar(50))
    - 입학일자 -> EntranceDate (date) : 부가정보
    - 졸업일자 -> GraduateDate (date) : 부가정보
    - Constraint
      - 학년Id + 반Id + 학생Seq (Unique)
        

  - 과목 -> TB_Subject

    - 과목Id (PK) -> SubjectId (tinyint)
    - 과목명 (Not Null)-> SubjectName (varchar(50))

  - 선생님 -> TB_Teacher

    - 선생님Id (PK) -> TeacherId (tinyint)
    - 선생님명 -> TeacherName (varchar(50))

  - 개강(관계) -> TB_OpenLecture

    - 일련번호 (AK, unique, Not Null, AutoIncremental) -> seq (bigint)
    - 선생님Id (PK, FK from 선생님) -> TeacherId (tinyint)
    - 학년Id (PK, FK from 학년) -> SchoolGradeId (tinyint)
    - 과목Id (PK, FK From 과목) -> SubjectId (tinyint)
    - 개강일 (PK) -> OpenDate (date)
      

  - 시험성적 (관계) -> TB_Score

    - 학생Id (PK, FK from 학생) -> StudentId (bigint)
    - 개강번호 (PK, FK from 개강 -> OpenLectureSeq (bigint)
    - 점수 (Not Null) -> Score (tinyint)

- 프로시져 생성: **부모없는 자식이 생길 수 없도록 생성하는게 중요**

  ```
  -- 학년
  CREATE PROCEDURE SP_Insert_SchoolClass
  	@SchoolGradeId tinyint,
  	@SchoolClassId tinyint,
  	@SchoolClassName varchar(50),
  AS
  BEGIN
  	INSERT INTO TB_SchoolClass (SchoolGradeId, SchoolClassId, SchoolClassName)
  	VALUES (@SchoolGradeId, @SchoolClassId, @SchoolClassName)
  END
  GO
  -- 필요 프로시저 예시
  -- SP_SchoolClass_GetById(gradeId, classId)
  -- SP_SchoolClass_GetAll();
  -- SP_SchoolClass_GetByGrade(gradeId)
  -- SP_Update_SchoolClassName
  
  -- 실행
  exec SP_Insert_SchoolClass 1,1,'1반'
  ```



## 정규화

### Anomaly: 데이터 중복에 의한 이상현상

- 데이터 모델링에서 가장 중요한 것 : 무결성 보장
- 불량테이블 예시 선수테이블 + 팀테이블 (밑에 테이블은 join으 결과로 나타나야 할 테이블)

| #선수번호 PK | 선수이름 | 포지션 | #팀번호 PK | 팀이름   |
| ------------ | -------- | ------ | ---------- | -------- |
| 10           | 홍길동   | 유격수 | 25         | 라이거스 |
| 14           | 강길동   | 투수   | 25         | 라이거스 |
| 15           | 박길동   | 중견수 | 25         | 라이거스 |
| 13           | 이길동   | 포수   | 20         | 라이언스 |
| 14           | 강길동   | 투수   | 10         | 타이언스 |
| 12           | 김길동   | 1루수  | 05         | 타이거스 |
| 10           | 홍길동   | 유격수 | 10         | 타이언스 |
| 11           | 최길동   | 2루수  | 10         | 타이언스 |
| 12           | 김길동   | 1루수  | 15         | 엘리펀츠 |
| 10           | 홍길동   | 유격수 | 30         | 캣츠     |

#### Update Anomaly

- 홍길동을 2루수로 바꿀 때
  - 일부 홍길동이 바뀌지 않을 수 있음
    - 홍길동이 중복으로 나타나기 때문
      - 홍길동을 찾는 조건에 팀번호가 관여하면 다른 팀에 소속된 홍길동은 값이 바뀌지 않을 수 있음
  - 정규화에서는
    - 홍길동일 중복으로 나타날 수 없다.
      - 따라서, 홍길동의 속성인 포지션을 한번만 바꾸면 전체가 업데이트 되는 효과

#### Delete Anomaly

- 김길동을 삭제할 때
  - 의도하지 않은 타이거스, 엘리펀츠 팀 정보가 사라질 수 있다.
    - 팀 정보가 유일했기 때문에 발생
  - 정규화에서는
    - 김길동만 사라질 뿐, 팀 정보는 그대로 유지할 수 있다.

#### Insert Anomaly

- 장길동이라는 새로운 선수를 등력할 때
  - 팀이 결정되지 않았다면 입력할 수 없는 문제가 발생
    - 선수는 존재하는데 입력할 수 없는 이상 현상이 발생
  - 다른 데이터가 존재하지 않아 원하는 데이터를 입력할 수 없는 것이 삽입 이상 현상

#### 개선 테이블, 선수:팀 =  M:N

- 선수

  | #선수번호 | 선수이름 | 포지션 |
  | --------- | -------- | ------ |
  | 10        | 홍길동   | 유격수 |
  | 14        | 강길동   | 투수   |
  | 15        | 박길동   | 중견수 |
  | 13        | 이길동   | 포수   |
  | 12        | 김길동   | 1루수  |
  | 11        | 최길동   | 2루수  |

- 팀

  | #팀번호 | 팀이름   |
  | ------- | -------- |
  | 25      | 라이거스 |
  | 20      | 라이언스 |
  | 10      | 타이언스 |
  | 5       | 타이거스 |
  | 15      | 엘리펀츠 |
  | 30      | 캣츠     |

- 소속(하다)

  | #선수번호 | #팀번호 |
  | --------- | ------- |
  | 10        | 25      |
  | 14        | 25      |
  | 15        | 25      |
  | 13        | 20      |
  | 14        | 10      |
  | 12        | 05      |
  | 10        | 10      |
  | 11        | 10      |
  | 12        | 15      |
  | 10        | 30      |



### 정규화 맛보기

#### 쇼핑리스트 테이블

| 주문번호 | 날짜 | 고객   | 연락처  | 주문상품                |
| -------- | ---- | ------ | ------- | ----------------------- |
| 1        | 1/1  | 박준용 | 010-xxx | 01배1박스, 02사과10박스 |
| 2        | 2/1  | 김재진 | 010-xxx | 03콩1Kg, 04두부2모      |
| 3        | 2/5  | 박준용 | 010-xxx | 05쌀20Kg, 06보리1Kg     |

- 주문상품처럼 한 컬럼에 여러개의 아이템이 있는 상태: 다가속성 (제거대상) -> 레코드 확장

  - 01배1박스, 02사과10박스 : 2개의 아이템 (,)

  - 레코드 확장하여 다가속성을 제거하게 되면 다른 속성의 **중복이 발생**한다: 주문번호, 날짜, 성명, 연락처

    | 주문번호 | 날짜 | 고객   | 연락처  | 주문상품     |
    | -------- | ---- | ------ | ------- | ------------ |
    | 1        | 1/1  | 박준용 | 010-xxx | 01배1박스    |
    | 1        | 1/1  | 박준용 | 010-xxx | 02사과10박스 |

- 한 컬럼에 여러개의 의미로 이루어진 경우: 복합속성 (제거대상) -> 컬럼 확장

  - 01배1박스 : 코드 + 상품명 + 단위

    | 주문번호 | 날짜 | 고객   | 연락처  | 상품코드 | 상품명 | 상품개수 |
    | -------- | ---- | ------ | ------- | -------- | ------ | -------- |
    | 1        | 1/1  | 박준용 | 010-xxx | 01       | 배     | 1박스    |
    | 1        | 1/1  | 박준용 | 010-xxx | 02       | 사과   | 10박스   |

  - 데이터 중복을 제거하기 위해 테이블 분할 : **1정규화**

    - 주문이력:주문상세 = 1:M의 관계형성

    - 주문이력

      | 주문번호(PK) | 날짜 | 고객   | 연락처  |
      | ------------ | ---- | ------ | ------- |
      | 1            | 1/1  | 박준용 | 010-xxx |
      | 2            | 2/1  | 김재진 | 010-xxx |
      | 3            | 2/5  | 김준용 | 010-xxx |

      - PK와 별도로 속성관에 종속 관계가 존해가데 되면 테이블 분할: **3정규화**

      - 종송 관계가 있으면 중복 데이터가 생긴다 -> 이행 종속 관계를 분해

      - 연락처는 고객에 종속된다. 동일한 고객이 복수 주문시 중복된 연락처 데이터가 생긴다.

        - 고객 : 주문이력 = 1:M

        - 주문이력

          | 주문번호(PK) | 날짜 | 고객번호(FK) |
          | ------------ | ---- | ------------ |
          | 1            | 1/1  | 1            |
          | 2            | 2/1  | 2            |
          | 3            | 2/5  | 1            |

        - 고객

          | 고객번호(PK) | 성명   | 연락처  |
          | ------------ | ------ | ------- |
          | 1            | 박준용 | 010-XXX |
          | 2            | 김재진 | 010-XXX |

          

    - 주문상세

      | 주문번호(PK,FK) | 상품코드(PK) | 상품명 | 개수   |
      | --------------- | ------------ | ------ | ------ |
      | 1               | 01           | 배     | 1박스  |
      | 1               | 02           | 사과   | 10박스 |

      - 두 개 이상으로 구성된 PK의 일부 값에만 종속되는 속성은 테이블 분할 대상 : **2정규화**

      - 상품명은 상품코드에만 종속되고, 주문번호와는 관계없음

        - 상품:주문상세 = 1:M

        - 주문상세

          | 주문번호(PK,FK) | 상품코드(PK,FK) | 개수   |
          | --------------- | --------------- | ------ |
          | 1               | 01              | 1박스  |
          | 1               | 02              | 10박스 |
          | 2               | 01              | 1박스  |
          | 2               | 03              | 2모    |
          | 3               | 02              | 5박스  |
          | 3               | 03              | 4모    |

        - 상품

          | 상품코드(PK) | 상품명 |
          | ------------ | ------ |
          | 01           | 배     |
          | 02           | 사과   |
          | 03           | 두부   |

          

### 1정규화 -> 1:M 테이블 분리

- 모든 속성은 반드시 하나의 값을 가져야 한다. -> 다가속성  (N개의 값으로 이루어진 속성 제거)
- 더이상 쪼갤 수 없는 값만 가져야 한다. -> 복합속성 (쪼갤 수 있는 의미의 속성 제거)

#### 다가속성이 사용된 테이블

| #고객번호 | 고객명 | 주민번호 | 전화번호 |
| --------- | ------ | -------- | -------- |
| 100       | 홍길동 | 1        | 1,2,3    |
| 101       | 황진이 | 2        | 4,5      |

- 다가속성: 전화전호

- 고객번호로 유일한 전화번호를 식별불가

- 전화번호는 고객번호에 종속되지 않음

- FD: 고객번호 -> 고객명, FD1: 고객번호 -> 주민번호, FD2: 고객번호 -> 전화번호? (N개의 전화번호때문)

- 다가속성 제거: 레코드 증가

  | #고객번호 | 고객명 | 주민번호 | 전화번호 |
  | --------- | ------ | -------- | -------- |
  | 100       | 홍길동 | 1        | 1        |
  | 100       | 홍길동 | 1        | 2        |
  | 100       | 홍길동 | 1        | 3        |
  | 101       | 황진이 | 2        | 4        |
  | 101       | 황진이 | 2        | 5        |

  - 중복된 데이터가 만들어짐 : 고객번호, 고객명, 주민번호

  - 중복제거를 위한 테이블 분할, 1:M

    | #고객번호 (PK) | 고객명 | 주민번호 |
    | -------------- | ------ | -------- |
    | 100            | 홍길동 | 1        |
    | 101            | 황진이 | 2        |

    | #고객번호 (FK) | 전화번호 |
    | -------------- | -------- |
    | 100            | 1        |
    | 100            | 2        |
    | 100            | 3        |
    | 101            | 4        |
    | 101            | 5        |

#### 복합 속성이 사용된 테이블 (옵션)

| #고객번호 | 고객명 | 주민번호       |
| --------- | ------ | -------------- |
| 100       | 홍길동 | 123456-7890123 |

- 고객명을 성과 이름으로 구성된 복합 속성으로 볼 수 도 있음

- 따라서, 고객의 성과 이름을 따로 조회하는 경우가 업무에 효율적이라고 **판단된다면** 제거: 컬럼증가

  | #고객번호 | 고객성 | 고객명 | 주민번호       |
  | --------- | ------ | ------ | -------------- |
  | 100       | 홍     | 길동   | 123456-7890123 |

#### 유사한 속성이 반복되는 테이블

| #주문번호 | 고객번호 | 주문일자 | 상품번호 | 수량 | 상품번호2 | 수량2 | 상품번호3 | 수량3 |
| --------- | -------- | -------- | -------- | ---- | --------- | ----- | --------- | ----- |
| 1234      | 100      | 1998     | p1       | 2    | a1        | 1     | null      | null  |
| 1236      | 101      | 2018     | p2       | 1    | c2        | 1     | b2        | 2     |

- 반복 형태의 속성이 있어서는 안됨 -> 분리
  - #주문번호 (PK) | 고객번호 | 주문일자
  - #주문번호 (PK, FK) | #상품번호 (PK) | 주문수량

### 2정규화 (Whole Key Dependent)

- 두 개 이상으로 구성된 PK에서 발생
- 모든 일반 컬럼들은 후보 식별자 속성에 완전 종속 되어야 한다.
- 방법
  - 일반 속성 중에서
  - 후보 식별자 전체에 종속적이지 않은 속성을 찾아
  - 기본 테이블에서 제거
  - 그 속성의 결정자를 주 식별자로 하는 새로운 상위 테이블 생성
  - 주문_상품: 주문번호(PK) | 상품번호(PK) | 상품명 | 단가 | 주문수량 | 주문금액
    - FD: (PK) -> 주문수량
    - FD1: (PK) -> 주문금액
    - FD2: 상품번호 -> 상품명
    - FD3: 상품번호 -> 단가
  - 2정규화 하면
    - 상품: 상품번호(PK) | 상품명 | 단가
    - 주문_상품: 주문번호(PK) | 상품번호(PK, FK) | 주문수량 | 주문금액

### 3정규화

- 식별자가 아닌 일반 속성 간에는 종속성이 존재하지 않는다. (이행 종속성 제거)
- 주문: 주문번호(PK) | 고객번호 | 고객명 | 주문일자 | 배송요청일자
  - 고객번호 -> 고객명
- 3정규화 하면
  - 고객: 고객번호 (PK) | 고객명
  - 주문: 주문번호 (PK) | 고객번호(FK) | 주문일자 | 배송요청일자

### BC 정규화

- PK의 구성요소는 일반 속성에 종속되면 안된다.

- #A | #B | C | D 

  - #A + #B -> C, D
  - C -> #B  (안됨)

- BC정규화하면, 일반 속성원 원래 테이블의 PK에 포함시키고 FK로 만들고 별도의 테이블의 PK로 지정 및 종속되던 속성을 옮긴다.

  - #A | #C | D
  - #C| B

- 예시

  - 교수는 정해진 한 과목만 강의할 수 있다.
  - 여러 교수가 동일한 과목을 강의할 수 없다. 따라서 과목을 알면 교수를 알 수 있다고 가정한다.

  | #학생번호 | #교수번호 | 과목번호 | 학점 |
  | --------- | --------- | -------- | ---- |
  | 1         | 1         | 1        | A    |
  | 1         | 2         | 2        | B    |
  | 1         | 3         | 3        | B    |
  | 2         | 2         | 2        | C    |
  | 2         | 4         | 4        | A    |

  FD: (#학생번호, #교수번호) -> (과목번호, 학점)

  FD: 과목번호 -> 교수번호

  - BC 정규화하면
    - #학생번호, #과목번호, 학점
    - #과목번호, 교수번호

### 역정규화

- 효율을 위해서 정규화된 결과의 일부를 수정하여 중복을 만든다.
  - JOIN시 발생되는 엄청난 계산(부하)를 해결하기 위해서 사용
  - 역정규화된 테이블은 중복값이 있는 테이블의 FK를 가져야 하며 참조무결성을 유지해야 한다.
    - 고객: 고객번호(PK), **고객명**
    - 주문: 주문번호(PK), 고객번호(FK), **고객명**, 주문일자, 배송요청일자

### 기타

통계데이터 설계

| 일자    | 테이블명 | 입금합 | 출금합 |
| ------- | -------- | ------ | ------ |
| 2019-11 |          |        |        |
| 2019-12 |          |        |        |
| ...     |          |        |        |

2019-11 장부 테이블명

| 일자       | 테이블명 | 입금 | 출금 |
| ---------- | -------- | ---- | ---- |
| 2019-11-01 |          |      |      |
| 2019-11-02 |          |      |      |
| ...        |          |      |      |